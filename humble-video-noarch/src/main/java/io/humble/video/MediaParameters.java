/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package io.humble.video;
import io.humble.ferry.*;
/**
 * A virtual class for MediaParameters
 */
public class MediaParameters extends RefCounted {
  // JNIHelper.swg: Start generated code
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>
  /**
   * This method is only here to use some references and remove
   * a Eclipse compiler warning.
   */
  @SuppressWarnings("unused")
  private void noop()
  {
    Buffer.make(null, 1);
  }
   
  private volatile long swigCPtr;

  /**
   * Internal Only.
   */
  protected MediaParameters(long cPtr, boolean cMemoryOwn) {
    super(VideoJNI.MediaParameters_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }
  
  /**
   * Internal Only.
   */
  protected MediaParameters(long cPtr, boolean cMemoryOwn,
      java.util.concurrent.atomic.AtomicLong ref)
  {
    super(VideoJNI.MediaParameters_SWIGUpcast(cPtr),
     cMemoryOwn, ref);
    swigCPtr = cPtr;
  }
    
  /**
   * Internal Only.  Not part of public API.
   *
   * Get the raw value of the native object that obj is proxying for.
   *   
   * @param obj The java proxy object for a native object.
   * @return The raw pointer obj is proxying for.
   */
  protected static long getCPtr(MediaParameters obj) {
    if (obj == null) return 0;
    return obj.getMyCPtr();
  }

  /**
   * Internal Only.  Not part of public API.
   *
   * Get the raw value of the native object that we're proxying for.
   *   
   * @return The raw pointer we're proxying for.
   */  
  protected long getMyCPtr() {
    if (swigCPtr == 0) throw new IllegalStateException("underlying native object already deleted");
    return swigCPtr;
  }
  
  /**
   * Create a new MediaParameters object that is actually referring to the
   * exact same underlying native object.
   *
   * @return the new Java object.
   */
  @Override
  public MediaParameters copyReference() {
    if (swigCPtr == 0)
      return null;
    else
      return new MediaParameters(swigCPtr, swigCMemOwn, getJavaRefCount());
  }

  /**
   * Compares two values, returning true if the underlying objects in native code are the same object.
   *
   * That means you can have two different Java objects, but when you do a comparison, you'll find out
   * they are the EXACT same object.
   *
   * @return True if the underlying native object is the same.  False otherwise.
   */
  public boolean equals(Object obj) {
    boolean equal = false;
    if (obj instanceof MediaParameters)
      equal = (((MediaParameters)obj).swigCPtr == this.swigCPtr);
    return equal;
  }
  
  /**
   * Get a hashable value for this object.
   *
   * @return the hashable value.
   */
  public int hashCode() {
     return (int)swigCPtr;
  }
  
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<
  // JNIHelper.swg: End generated code
  

/**
 * Get the timebase for this MediaParameters set of properties 
 */
  public Rational getTimeBase() {
    long cPtr = VideoJNI.MediaParameters_getTimeBase(swigCPtr, this);
    return (cPtr == 0) ? null : new Rational(cPtr, false);
  }

/**
 * Sets the timebase 
 */
  public void setTimeBase(Rational tb) {
    VideoJNI.MediaParameters_setTimeBase(swigCPtr, this, Rational.getCPtr(tb), tb);
  }

/**
 * General type of the encoded data.
 */
  public SWIGTYPE_p_MediaDescriptor__Type getType() {
    return new SWIGTYPE_p_MediaDescriptor__Type(VideoJNI.MediaParameters_getType(swigCPtr, this), true);
  }

/**
 * Specific type of the encoded data (the codec used).
 */
  public SWIGTYPE_p_Codec__ID getID() {
    return new SWIGTYPE_p_Codec__ID(VideoJNI.MediaParameters_getID(swigCPtr, this), true);
  }

/**
 * Additional information about the codec (corresponds to the AVI FOURCC).
 */
  public long getTag() {
    return VideoJNI.MediaParameters_getTag(swigCPtr, this);
  }

/**
 * Extra binary data needed for initializing the decoder, codec-dependent.<br>
 * <br>
 * Must be allocated with av_malloc() and will be freed by<br>
 * avcodec_parameters_free(). The allocated size of extradata must be at<br>
 * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding<br>
 * bytes zeroed.<br>
 * <br>
 * Size of the extradata content in bytes.<br>
 * <br>
 * Get the Pixel Format, or PixelFormat.PIX_FMT_NONE if the parameter #getType()<br>
 * is not MediaDescriptor.MEDIA_VIDEO.<br>
 * <br>
 * @return the pixel format.
 */
  public PixelFormat.Type getPixelFormat() {
    return PixelFormat.Type.swigToEnum(VideoJNI.MediaParameters_getPixelFormat(swigCPtr, this));
  }

/**
 * Sets the pixel format (it is up to the caller<br>
 * to ensure that #getType() is MediaDescriptor.MEDIA_VIDEO. Otherwise<br>
 * behaviour is undefined.<br>
 * <br>
 * @param format Pixel Format to set format to.<br>
 * @see #getPixelFormat()
 */
  public void setPixelFormat(PixelFormat.Type format) {
    VideoJNI.MediaParameters_setPixelFormat(swigCPtr, this, format.swigValue());
  }

/**
 * Get the Audio Format, or AudioFormat.SAMPLE_FMT_NONE if the parameter #getType()<br>
 * is not MediaDescriptor.MEDIA_AUDIO.<br>
 * <br>
 * @return the audio format.
 */
  public SWIGTYPE_p_AudioFormat__Type getAudioFormat() {
    return new SWIGTYPE_p_AudioFormat__Type(VideoJNI.MediaParameters_getAudioFormat(swigCPtr, this), true);
  }

/**
 * Sets the audio format (it is up to the caller<br>
 * to ensure that #getType() is MediaDescriptor.MEDIA_AUDIO. Otherwise<br>
 * behaviour is undefined.<br>
 * <br>
 * @param format Audio Format to set format to.<br>
 * @see #getAudioFormat()
 */
  public void setAudioFormat(SWIGTYPE_p_AudioFormat__Type format) {
    VideoJNI.MediaParameters_setAudioFormat(swigCPtr, this, SWIGTYPE_p_AudioFormat__Type.getCPtr(format));
  }

/**
 * Get the average bit-rate (in bits per second) of encoded data.<br>
 * @return the bit rate.
 */
  public long getBitRate() {
    return VideoJNI.MediaParameters_getBitRate(swigCPtr, this);
  }

/**
 * Set the bit-rate (in bits per second) of encoded data.<br>
 * @param bit_rate the bit rate.
 */
  public void setBitRate(long bit_rate) {
    VideoJNI.MediaParameters_setBitRate(swigCPtr, this, bit_rate);
  }

/**
 * Get the number of bits per sample in the codedwords.<br>
 * <p><br>
 * This is basically the bitrate per sample. It is mandatory for a bunch of<br>
 * formats to actually decode them. It's the number of bits for one sample in<br>
 * the actual coded bitstream.<br>
 * </p><br>
 * <p><br>
 * This could be for example 4 for ADPCM<br>
 * For PCM formats this matches bits_per_raw_sample<br>
 * </p><br>
 * <p><br>
 * Can be 0.<br>
 * </p>
 */
  public long getBitsPerCodedSample() {
    return VideoJNI.MediaParameters_getBitsPerCodedSample(swigCPtr, this);
  }

/**
 * Set the bits per coded sample.<br>
 * @param bitsPerCodedSample bits per coded sample.<br>
 * @see #getBitsPerCodedSample()
 */
  public void setBitsPerCodedSample(long bitsPerCodedSample) {
    VideoJNI.MediaParameters_setBitsPerCodedSample(swigCPtr, this, bitsPerCodedSample);
  }

/**
 * This is the number of valid bits in each output sample.<br>
 *         * <p><br>
 * If the sample format has more bits, the least significant bits are additional<br>
 * padding bits, which are always 0. Use right shifts to reduce the sample<br>
 * to its actual size. For example, audio formats with 24 bit samples will<br>
 * have bits_per_raw_sample set to 24, and format set to AudioFormat.SAMPLE_FMT_S32.<br>
 * To get the original sample use "(int32_t)sample >> 8"."<br>
 * </p><br>
 * <p><br>
 * For ADPCM this might be 12 or 16 or similar<br>
 * </p><br>
 * <p><br>
 * Can be 0.<br>
 * </p>
 */
  public long getBitsPerRawSample() {
    return VideoJNI.MediaParameters_getBitsPerRawSample(swigCPtr, this);
  }

/**
 * Sets the bits per raw sample.<br>
 * @param bitsPerRawSample bits per raw sample.<br>
 * @see #getBitsPerRawSample()
 */
  public void setBitsPerRawSample(long bitsPerRawSample) {
    VideoJNI.MediaParameters_setBitsPerRawSample(swigCPtr, this, bitsPerRawSample);
  }

/**
 * Codec-specific bitstream restrictions that the stream conforms to.<br>
 * @return the profile.
 */
  public long getProfile() {
    return VideoJNI.MediaParameters_getProfile(swigCPtr, this);
  }

/**
 * @see getProfile()
 */
  public void setProfile(long profile) {
    VideoJNI.MediaParameters_setProfile(swigCPtr, this, profile);
  }

/**
 * Codec-specific bitstream restriction level that the stream conforms to.<br>
 * @return the level.
 */
  public long getLevel() {
    return VideoJNI.MediaParameters_getLevel(swigCPtr, this);
  }

/**
 * See #getLevel()
 */
  public void setLevel(long level) {
    VideoJNI.MediaParameters_setLevel(swigCPtr, this, level);
  }

/**
 * Get the picture width in pixels. Video only.
 */
  public int getWidth() {
    return VideoJNI.MediaParameters_getWidth(swigCPtr, this);
  }

/**
 * @see #getWidth()
 */
  public void setWidth(int width) {
    VideoJNI.MediaParameters_setWidth(swigCPtr, this, width);
  }

/**
 * Get the picture height in pixels. Video only.
 */
  public int getHeight() {
    return VideoJNI.MediaParameters_getHeight(swigCPtr, this);
  }

/**
 * @see #getHeight()
 */
  public void setHeight(int height) {
    VideoJNI.MediaParameters_setHeight(swigCPtr, this, height);
  }

/**
 *  The aspect ratio (width / height) which a single pixel<br>
 * should have when displayed. Video only.<br>
 * <br>
 * When the aspect ratio is unknown / undefined, the numerator should be<br>
 * set to 0 (the denominator may have any value).
 */
  public Rational getSampleAspectRatio() {
    long cPtr = VideoJNI.MediaParameters_getSampleAspectRatio(swigCPtr, this);
    return (cPtr == 0) ? null : new Rational(cPtr, false);
  }

/**
 * See #getSampleAspectRatio()
 */
  public void setSampleAspectRatio(Rational newValue) {
    VideoJNI.MediaParameters_setSampleAspectRatio(swigCPtr, this, Rational.getCPtr(newValue), newValue);
  }

/**
 * Sets the field order. Video only.
 */
  public PixelFormat.FieldOrder getFieldOrder() {
    return PixelFormat.FieldOrder.swigToEnum(VideoJNI.MediaParameters_getFieldOrder(swigCPtr, this));
  }

/**
 * @see getFieldOrder()
 */
  public void setFieldOrder(PixelFormat.FieldOrder order) {
    VideoJNI.MediaParameters_setFieldOrder(swigCPtr, this, order.swigValue());
  }

/**
 * Get the color range. Video only.
 */
  public PixelFormat.ColorRange getColorRange() {
    return PixelFormat.ColorRange.swigToEnum(VideoJNI.MediaParameters_getColorRange(swigCPtr, this));
  }

/**
 * @see #getColorRange()
 */
  public void setColorRange(PixelFormat.ColorRange range) {
    VideoJNI.MediaParameters_setColorRange(swigCPtr, this, range.swigValue());
  }

/**
 * Get the color primaries. Video only.
 */
  public PixelFormat.ColorPrimaries getColorPrimaries() {
    return PixelFormat.ColorPrimaries.swigToEnum(VideoJNI.MediaParameters_getColorPrimaries(swigCPtr, this));
  }

/**
 * @see #getColorPrimaries()
 */
  public void setColorPrimaries(PixelFormat.ColorPrimaries primaries) {
    VideoJNI.MediaParameters_setColorPrimaries(swigCPtr, this, primaries.swigValue());
  }

/**
 * Get the color transfer characteristic. Video only.
 */
  public PixelFormat.ColorTransferCharacteristic getColorTransferCharacteristic() {
    return PixelFormat.ColorTransferCharacteristic.swigToEnum(VideoJNI.MediaParameters_getColorTransferCharacteristic(swigCPtr, this));
  }

/**
 * See #getColorTransferCharacteristic()
 */
  public void setColorTransferCharacteristic(PixelFormat.ColorTransferCharacteristic trc) {
    VideoJNI.MediaParameters_setColorTransferCharacteristic(swigCPtr, this, trc.swigValue());
  }

/**
 * Get the color space. Video only.
 */
  public PixelFormat.ColorSpace getColorSpace() {
    return PixelFormat.ColorSpace.swigToEnum(VideoJNI.MediaParameters_getColorSpace(swigCPtr, this));
  }

/**
 * @see #getColorSpace()
 */
  public void setColorSpace(PixelFormat.ColorSpace space) {
    VideoJNI.MediaParameters_setColorSpace(swigCPtr, this, space.swigValue());
  }

/**
 * Get the chroma location. Video only.<br>
 * @see PixelFormat.ChromaLocation
 */
  public PixelFormat.ChromaLocation getChromaLocation() {
    return PixelFormat.ChromaLocation.swigToEnum(VideoJNI.MediaParameters_getChromaLocation(swigCPtr, this));
  }

/**
 * @see #getChromaLocation()
 */
  public void setChromaLocation(PixelFormat.ChromaLocation loc) {
    VideoJNI.MediaParameters_setChromaLocation(swigCPtr, this, loc.swigValue());
  }

/**
 * Number of delayed frames. Video only.
 */
  public int getVideoDelay() {
    return VideoJNI.MediaParameters_getVideoDelay(swigCPtr, this);
  }

/**
 * @see #getVideoDelay()
 */
  public void setVideoDelay(int delay) {
    VideoJNI.MediaParameters_setVideoDelay(swigCPtr, this, delay);
  }

/**
 * The channel layout bitmask. Audio only. May be 0 if the channel layout is<br>
 * unknown or unspecified, otherwise the number of bits set must be equal to<br>
 * the channels field.
 */
  public java.math.BigInteger getChannelLayout() {
    return VideoJNI.MediaParameters_getChannelLayout(swigCPtr, this);
  }

/**
 * @see #getChannelLayout()
 */
  public void setChannelLayout(java.math.BigInteger layout) {
    VideoJNI.MediaParameters_setChannelLayout(swigCPtr, this, layout);
  }

/**
 * The number of audio channels. Audio only.
 */
  public int getChannels() {
    return VideoJNI.MediaParameters_getChannels(swigCPtr, this);
  }

/**
 * @see #getChannels()
 */
  public void setChannels(int channels) {
    VideoJNI.MediaParameters_setChannels(swigCPtr, this, channels);
  }

/**
 * The number of audio samples per second. Audio only.
 */
  public int getSampleRate() {
    return VideoJNI.MediaParameters_getSampleRate(swigCPtr, this);
  }

/**
 * @see #getSampleRate()
 */
  public void setSampleRate(int rate) {
    VideoJNI.MediaParameters_setSampleRate(swigCPtr, this, rate);
  }

/**
 * The number of bytes per coded audio frame, required by some<br>
 * formats. Audio only.<br>
 * <br>
 * Corresponds to nBlockAlign in WAVEFORMATEX.
 */
  public int getBlockAlign() {
    return VideoJNI.MediaParameters_getBlockAlign(swigCPtr, this);
  }

  public void setBlockAlign(int align) {
    VideoJNI.MediaParameters_setBlockAlign(swigCPtr, this, align);
  }

/**
 * Audio frame size, if known. Audio only. Required by some formats to be static.
 */
  public int getFrameSize() {
    return VideoJNI.MediaParameters_getFrameSize(swigCPtr, this);
  }

/**
 * @see #getFrameSize()
 */
  public void setFrameSize(int size) {
    VideoJNI.MediaParameters_setFrameSize(swigCPtr, this, size);
  }

/**
 * The amount of padding (in samples) inserted by the encoder at<br>
 * the beginning of the audio. Audio only. I.e. this number of leading decoded samples<br>
 * must be discarded by the caller to get the original audio without leading<br>
 * padding.
 */
  public int getInitialPadding() {
    return VideoJNI.MediaParameters_getInitialPadding(swigCPtr, this);
  }

/**
 * @see #getInitialPadding()
 */
  public void setInitialPadding(int pad) {
    VideoJNI.MediaParameters_setInitialPadding(swigCPtr, this, pad);
  }

/**
 * The amount of padding (in samples) appended by the encoder to<br>
 * the end of the audio. Audio only. I.e. this number of decoded samples must be<br>
 * discarded by the caller from the end of the stream to get the original<br>
 * audio without any trailing padding.
 */
  public int getTrailingPadding() {
    return VideoJNI.MediaParameters_getTrailingPadding(swigCPtr, this);
  }

/**
 * @see #getTrailingPadding()
 */
  public void setTrailingPadding(int pad) {
    VideoJNI.MediaParameters_setTrailingPadding(swigCPtr, this, pad);
  }

/**
 * Number of samples to skip after a discontinuity. Audio only.
 */
  public int getSeekPreroll() {
    return VideoJNI.MediaParameters_getSeekPreroll(swigCPtr, this);
  }

/**
 * @see #getSeekPreroll()
 */
  public void setSeekPreroll(int preroll) {
    VideoJNI.MediaParameters_setSeekPreroll(swigCPtr, this, preroll);
  }

}
